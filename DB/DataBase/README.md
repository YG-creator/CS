# 1. DB 쓰는 이유

## 1. 독립성

물리적 독립성 : DB 변경시 응용프로그램 변경안해도 됨

논리적 독립성 : 논리적 구조로 다양한 응용프로그램의 요구 만족

## 2. 무결성

유효성 검사 ->  잘못된 데이터 방지

## 3. 보안성

인가된 사용자만 접근가능하게 함

## 4. 일관성

논리적 구조로 관리 -> 일부 데이터만 변경시 불일치성 배제

## 5. 중복 최소화

데이터 통합해서 관리



# 2. DB 성능 

DB 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.



# 3. Index

* 데이터가 저장되는 주소
* 저장성능이 떨어지나 읽기 속도는 빨라짐
* 생성하는데 B+- Tree 알고리즘 사용

## 자료구조 

1. B+-Tree

   원래의 값을 이용해 인덱싱

   부등호 연산 가능

2. Hash

   원래의 값이 아닌 해시 값을 이용해 인덱싱

   시간복잡도 O(1)

   부분 검색시 사용 못함
   
   부등호 연산 불가능

## Clustered Index

프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것

테이블당 하나만 생성 가능(프라이커리 키 사용해서)



## Composite Index

속성 여러개를 Index로 설정



## 성능 효율성

* 모든 속성에 INDEX를 생성해두면 안좋음
  * INSERT : 데이터 추가됨
  * DELETE : 데이터 그대로임(안쓴다는 표시만 함)
  * UPDATE : INSERT + DELETE

* 값 종류가 많은 속성을 Index로 설정하는것이 효율적



# 4. 정규화



## 원인

데이터 중복으로 인한 이상현상 -> 갱신이상 발생(삽입, 삭제, 수정)

## 정규화란

나쁜 릴레이션의 애트리뷰트들을 나누어서 **좋은** 작은 릴레이션으로 분해하는 작업 -> 중복 최소화

## 함수 종속성

X -> Y (1개)

## 종류(도부이걸다조)

1. 제1 정규형

   튜플은 도메인에 속하는 하나의 원자값만을 가져야 한다.

2. 제2 정규형

   앞 정규형 + 부분적 종속 제거(X->Y(1개) 이여야 됨)

3. 제3정규형

   앞 정규형 + 이행적 종속 제거(X->Y->Z 를 X-> Y 와  Y->Z로 나누기)

4. BCNF 정규형

​		앞 정규형 + 후보키 일부를 분해

## 장점

1. DB 변경 시 이상현상 제거
2. DB 구조 확장 시 디자인 최소화
3. 데이터 모델이 현실세계 개념들을 반영함
4. 중복 속성을 제거해서 데이터 용량 최소화



## 단점

* JOIN 연산이 많아져서 성능 저하될수 있음



# 5. 반정규화



## 사용 이유

정규화 단점인 JOIN 연산이 많아져서 성능이 저하되는 것을 방지



## 대상

1. 테이블에 자주 사용 &&  일정범위만 조회하는 경우

2. 테이블에 대량 데이터 && 대량의 범위 자주 처리하는 경우

3. 조인연산 많은 경우 

    

## 단점

1. 무결성 깨질수 있음
2. 입력, 수정, 삭제의 응답 시간이 느려질 수 있음



# 6. 트랜잭션

논리적인 작업 셋을 모두 완벽하게 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능

## 트랜잭션 vs Lock

트랜잭션 : 완전성 보장

Lock : 동시성 제어



## 특징 ACID

1. 원자성(Automicity)

   중간에 문제가 발생하면 rollback

2. 일관성(Consistency)

   트랜잭션이 완료된 후에도 데이터 일관성 보장

3. 고립성(Isolation)

   트랜잭션 끼리 독립적

4. 지속성(Durablility)

​		트랜잭션 완료 후 commit

## 트랜잭션 상태

![image-20220411220427655](C:\Users\YG\AppData\Roaming\Typora\typora-user-images\image-20220411220427655.png)

* Active

  트랜잭션 실행 중

* Failed

  트랜잭션 실패 더이상 진행 불가

* Partially Committed

  sql문 실행 후 commit만 남은 상태

* Committed

  commit 완료

* Aborted

  트랜잭션 취소 후 rollback



## 주의점

1. 트랜잭션의 범위를 최소화 하자

2. 교착상태(두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태)

## 교착상태 해결법

1. 자주 커밋한다.
2. 정해진 순서로 테이블에 접근한다.
3. 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
4. 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다, 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.



# 7. PreparedStatement 사용 권장

* Statement 

  * 변수를 설정하고 바인딩하는 static sql 사용
  * 미리 쿼리가 컴파일 되어있지안레코드를 가져오는 과정이 오래걸림

  

* PreparedStatement

  * 쿼리 자체에 조건이 들어가는 dynamic sql 사용

  * 쿼리 수행하기 전에 쿼리가 컴파일 되어있어서 빠





# 8. NoSQL



## 1. 특징

* 관계형 데이터 모델을 지양
* 대량의 분산된 데이터를 저장하고 조회하는 데 특화
* 스키마 없이 사용 가능 or 느슨한 스키마를 제공하는 저장소
* 대량의 데이터를 빠르게 처리하기위해 임시 저장 후 응답



## 2. .CAP 이론

1. 일관성(Consistency)

   다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증

2. 가용성(Availability)

   모든 클라이언트에서 고장이 나도 읽기와 쓰기 요청에 대하여 항상 응답이 가능

3. 네트워크 분할 허용성

   네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함



## 3. 분류

1. Key-Value(키-값)

   복잡한 조회 연산을 지원하지 않는다

   고속 읽기와 쓰기에 최적화

   하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능

   ex) Redis

2. Document(키(ID) - 값)

   논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사

   문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성

   대부분 2 차 인덱스를 생성

   B 트리는 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능

   중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용

   ex) MongoDB

3. Column

   하나의 키에 여러 개의 컬럼 이름과 컬럼 값

   모든 컬럼은 항상 타임 스탬프 값과 함께 저장

   쓰기에 더 특화 

   커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공

   채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합

​	
