# 좋은 코드란?

- 읽기 쉬운 코드
- 중복이 없는 코드
- 테스트가 용이한 코드



# 객체 지향적 프로그래밍



## 1. 개념

현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것(추상화)



## 2. 장점

* 재사용성이 높다
* 신뢰성을 확보
* 어떻게 동작하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 생산성이 높아지게 된다
* 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다
* 디버깅이 쉽고 유지보수에 용이하다.
* 데이터 모델링을 할 때 객체와 매핑하는 것이 수월



## 3. 단점

* 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생



## 4. 설계 원칙

1. SRP(Single Responsibility Principle) : 단일 책임 원칙
   하나의 클래스는 단 하나의 책임을 가져서, 하나의 클래스를 변경할 때 그 클래스만 영향을 받아 파급력이 적다.

2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙
   확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. = 객체를 직접 수정하지 않고도 변경사항을 적용할 수 있도록 설계해야 한다

   OCP를 위해서는 DI, IoC가 필요하다.

3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
   상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. = 하위 타입의 객체는 인터페이스 규약을 지켜야 한다.

4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙

   범용 인터페이스 하나보다는 특정 클라이언트를 위한 여러 개의 인터페이스 분리가 더 좋다.

   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
   구현 클래스(구현체)가 아니라 인터페이스(역할)에 의존해야한다.

   인터페이스 객체를 변경사항이 발생해도 구현 클래스는 수정할 필요가 없어진다.



# API 



   ## 1. 개념

* 컴퓨터의 기능을 실행시키는 방법



## 2. 장점

* 어떻게 구현되어있는지 몰라고 기능을 사용할수 있다.



## 3. 단점

* API 공개 문서 필요

* private일 경우 사용이 제한됨

 

## API gateway

* web client 와 web server 징검다리

* web client 나 web server이 변경되면 API gateway만 바꿔주면됨

* API gateway Lambda(함수) : 서버 없이 application 가능





# REST API



## 1. 개념

남의 컴퓨터의 기능을 실행시키는 방법

API 설계의 중심에 자원(Resource)이 있고 HTTP Method 를 통해 자원을 처리하도록 설계하는 것이다.

1. **리소스** 와 **행위**(HTTP Method(GET,POST,PUT(전체수정),PATCH(부분수정),DELETE)) 를 명시적이고 직관적으로 분리한다.
2. Message 는 Header 와 Body 를 명확하게 분리해서 사용한다.
3. API 버전을 관리한다.
4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.



## 2. 장점

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.



## 3. 단점

1. 사용할 수 있는 메소드가 4 가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.



# TDD



## 1. 개념

* 새로운 기능에 대한 테스트케이스 작성 -> 테스트를 통과하는 가장 간단한 코드 작성 -> 리팩토링



## 2. 장점

* 요구사항과 명세를 파악에 도움됨

* 새로운 기능이 제대로 작동함과 동시에 기존의 기능들이 잘 작동하는지 테스트를 통해 확인 가능

* 뚱뚱해진 함수를 여러 함수로 나누는 과정을 통해 리팩토링 속도도 빨라지고 코드의 퀄리티도 그만큼 향상

* 보다 객체지향적이고 확장 가능이 용이
* 재설계의 시간을 단축 
* 디버깅 시간 단축



## 3. 단점

* 코드량이 늘어서 시간, 생산성 저하
* 테스트 코드 작성이 어려움
* 테스트가 불필요한 경우가 있음(주객전도)



# 함수형 프로그래밍



## 특징

1. immutable : 객체 변경 불가 - 값이 변경될때 새로운 객체 생성해야됨
2. first citizen - 함수의 반환값을 변수나 인수값으로 전달 가능



# MVC

Model + View + Controller

![image-20220322220207435](C:\Users\YG\AppData\Roaming\Typora\typora-user-images\image-20220322220207435.png)

## 1. Model

* 비즈니스 로직을 구현하는 영역

* DB에 연결하고 데이터 추출, 저장, 삭제, 수정

* 상태변화가 있을 때 controller 와 view에 통보해 후속조치 받을 수 있게 함



## 2. View

* Controller로부터 받은 Model의 결과값을 사용자 화면에 출력





## 3. Controller

* 클라이언트에서 요청이 왔을 때 그 요청 업무를 수행하는 컴포넌트를 호출한다.

* 클라이언트가 보낸 데이터를 가공
* Model의 결과값을 View에게 전달



# Oauth 2.0

![image-20220407184318225](C:\Users\YG\AppData\Roaming\Typora\typora-user-images\image-20220407184318225.png)

```java
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount	// 구글 로그인 페이지 요청
?client_id=	// 구글 로그인 성공하면 보내주는 id
&redirect_uri=http://localhost:3000/login	// 로그인하고 다시 돌아올곳
&response_type=code	// token 받을 때 필요한거
&scope=https://www.googleapis.com/auth/userinfo.email	// 범위 설정
```



# DTO 와 객체 분리하는 이유

1) 관심사의 분리

   **DTO(Data Transfer Object)의 핵심 관심사는 데이터의 전달**

   **엔티티는 핵심 비즈니스 로직을 담는 비즈니스 도메인 영역의 일부**

2) Validation 로직 및 불필요한 코드 등과의 분리

   유효성 검증을 위한 코드 등이 추가되면서 엔티티 클래스가 지나치게 비대해질 것이고, 

   확장 및 유지보수 등에서 매우 어려움을 겪게 될 것이다. 

3) API 스펙과의 분리

   **DTO를 이용해 분리하여 독립성을 높임으로써 변경이 전파되는 것을 방지해야 한다**

4) API 스펙의 파악이 용이

​	   DTO를 통해 API 스펙을 어느정도 파악할 수 있다
